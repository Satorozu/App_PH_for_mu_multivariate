return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
df1<-p
df2<-n-p
method<-c('F test to compare two variances')
alternative <-'less'
res<-list(statistics=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
plot.htest(x)
install.packages("mvtnorm")
plot.htest(x)
x<-To(dt,0.05,c(4,50,10))
x
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
df1<-p
df2<-n-p
names(statistic) <- 'Z'
attr(conf.int, 'alpha') <- conf.level
estimate<- M0
method<-c('F test to compare two variances')
data.frame<- deparse(substitute(x))
alternative <-'less'
res<-list(statistic=statistic,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
df1<-p
df2<-n-p
names(statistic) <- 'Z'
attr(conf.int, 'alpha') <- conf.level
estimate<- M0
method<-c('F test to compare two variances')
data.frame<- deparse(substitute(x))
alternative <-'less'
res<-list(statistic=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
df1<-p
df2<-n-p
names(statistic) <- 'Z'
attr(conf.int, 'alpha') <- conf.level
estimate<- M0
method<-c('F test to compare two variances')
data.frame<- deparse(substitute(x))
alternative <-'less'
res<-list(statistics=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
df1<-p
df2<-n-p
attr(conf.int, 'alpha') <- conf.level
estimate<- M0
method<-c('F test to compare two variances')
data.frame<- deparse(substitute(x))
alternative <-'less'
res<-list(statistics=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
df1<-p
df2<-n-p
estimate<- M0
method<-c('F test to compare two variances')
alternative <-'less'
res<-list(statistics=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
plot.htest(x)
qf(5,2)
qf(0.05,5,2)
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
f<-as.numeric(f)
df1<-p
df2<-n-p
estimate<- M0
method<-c('F test to compare two variances')
alternative <-'less'
res<-list(statistics=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
plot.htest(x)
plot.htest <- function(x, col='red', shade.col='red', cex=0.8, ...) {
# Z test
if (x$method %in% c('One Sample z-test',
'Z test for mean')) {
if (x$alternative == 'less')
asbio::shade.norm(x=x$statistic, tail='lower',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.norm(x=x$statistic, tail='upper',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.norm(x=x$statistic, tail="two",
las=1, shade.col=shade.col, cex=cex)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
# for 1 prop test
if (x$method %in% c('1-sample proportions test with continuity correction',
'1-sample proportions test without continuity correction')) {
x$statistic <- sign(x$estimate - x$null.value) * sqrt(x$statistic)
if (x$alternative == 'less')
asbio::shade.norm(x=x$statistic, tail='lower',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.norm(x=x$statistic, tail='upper',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.norm(x=x$statistic, tail="two",
las=1, shade.col=shade.col, cex=cex)
}
# for 2 prop test
if (x$method %in% c('2-sample test for equality of proportions with continuity correction',
'2-sample test for equality of proportions without continuity correction')) {
x$statistic <- sign(x$estimate[1] - x$estimate[2]) * sqrt(x$statistic)
if (x$alternative == 'less')
asbio::shade.norm(x=x$statistic, tail='lower',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.norm(x=x$statistic, tail='upper',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.norm(x=x$statistic, tail="two",
las=1, shade.col=shade.col, cex=cex)
}
# t test
if (x$method %in% c('One Sample t-test',
'Welch Two Sample t-test',
' Two Sample t-test',
'Two Sample t-test',
'Paired t-test')) {
if (x$alternative == 'less')
asbio::shade.t(x=x$statistic, tail='lower',
nu=x$parameter,
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.t(x=x$statistic, tail='upper',
nu=x$parameter,
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.t(x=x$statistic, tail="two",
nu=x$parameter,
las=1, shade.col=shade.col, cex=cex)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
# Chi squared test
if (x$method %in% c('X-squared test for variance')) {
if (x$alternative == 'less')
asbio::shade.chi(x=x$statistic, nu=x$parameter,
tail='lower', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.chi(x=x$statistic, nu=x$parameter,
tail='upper', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.chi(nu=x$parameter, tail="two",
las=1, shade.col=shade.col, cex=cex,
prob.to.each.tail=x$p.value/2)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
# F test
if (x$method %in% c('F test to compare two variances')) {
if (x$alternative == 'less')
asbio::shade.F(x=x$statistic,
nu1=x$df1,
nu2=x$df2,
tail='lower', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.F(x=x$statistic,
nu1=x$df1,
nu2=x$df2,
tail='upper', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.F(nu1=x$df1,
nu2=x$df2,
tail="two",
shade.col=shade.col, cex=cex,
prob.to.each.tail=x$p.value/2, las=1)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
}
plot.htest(x)
x<-To(dt,0.05,c(4,50,10))
x<-To(dt,0.05,c(4,20,10))
plot.htest(x)
x<-To(dt,0.05,c(4,20,100))
plot.htest(x)
#grafico valor p
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
f<-as.numeric(f)
df1<-p
df2<-n-p
estimate<- M0
method<-c('F test to compare two variances')
alternative <-'less'
res<-list(statistics=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,method=method,df1=df1,df2=df2,alternative=alternative)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
plot.htest <- function(x, col='red', shade.col='red', cex=0.8, ...) {
# Z test
if (x$method %in% c('One Sample z-test',
'Z test for mean')) {
if (x$alternative == 'less')
asbio::shade.norm(x=x$statistic, tail='lower',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.norm(x=x$statistic, tail='upper',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.norm(x=x$statistic, tail="two",
las=1, shade.col=shade.col, cex=cex)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
# for 1 prop test
if (x$method %in% c('1-sample proportions test with continuity correction',
'1-sample proportions test without continuity correction')) {
x$statistic <- sign(x$estimate - x$null.value) * sqrt(x$statistic)
if (x$alternative == 'less')
asbio::shade.norm(x=x$statistic, tail='lower',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.norm(x=x$statistic, tail='upper',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.norm(x=x$statistic, tail="two",
las=1, shade.col=shade.col, cex=cex)
}
# for 2 prop test
if (x$method %in% c('2-sample test for equality of proportions with continuity correction',
'2-sample test for equality of proportions without continuity correction')) {
x$statistic <- sign(x$estimate[1] - x$estimate[2]) * sqrt(x$statistic)
if (x$alternative == 'less')
asbio::shade.norm(x=x$statistic, tail='lower',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.norm(x=x$statistic, tail='upper',
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.norm(x=x$statistic, tail="two",
las=1, shade.col=shade.col, cex=cex)
}
# t test
if (x$method %in% c('One Sample t-test',
'Welch Two Sample t-test',
' Two Sample t-test',
'Two Sample t-test',
'Paired t-test')) {
if (x$alternative == 'less')
asbio::shade.t(x=x$statistic, tail='lower',
nu=x$parameter,
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.t(x=x$statistic, tail='upper',
nu=x$parameter,
las=1, shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.t(x=x$statistic, tail="two",
nu=x$parameter,
las=1, shade.col=shade.col, cex=cex)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
# Chi squared test
if (x$method %in% c('X-squared test for variance')) {
if (x$alternative == 'less')
asbio::shade.chi(x=x$statistic, nu=x$parameter,
tail='lower', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.chi(x=x$statistic, nu=x$parameter,
tail='upper', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.chi(nu=x$parameter, tail="two",
las=1, shade.col=shade.col, cex=cex,
prob.to.each.tail=x$p.value/2)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
# F test
if (x$method %in% c('F test to compare two variances')) {
if (x$alternative == 'less')
asbio::shade.F(x=x$statistic,
nu1=x$df1,
nu2=x$df2,
tail='lower', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'greater')
asbio::shade.F(x=x$statistic,
nu1=x$df1,
nu2=x$df2,
tail='upper', las=1,
shade.col=shade.col, cex=cex)
if (x$alternative == 'two.sided')
asbio::shade.F(nu1=x$df1,
nu2=x$df2,
tail="two",
shade.col=shade.col, cex=cex,
prob.to.each.tail=x$p.value/2, las=1)
title(main='Shaded area corresponds to p-value')
mtext(text=round(x$statistic, digits=4),
side=1, at=x$statistic,
col=col, cex=cex, adj=0.5)
}
}
plot.htest(x)
if (!require('devtools')) install.packages('devtools')
devtools::install_github('fhernanb/usefultools', force=TRUE)
if (!require('devtools')) install.packages('devtools')
devtools::install_github('fhernanb/usefultools', force=TRUE)
require(usefultools)
dt <- read.delim2("C:/Users/Durley Zuluaga/Desktop/santiago/final cali/app_modificable/App_PH1 - actual/base.txt")
View(dt)
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
res<-list(estadistico=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f)
return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
asbio::shade.F(x=x$statistic,
nu1=x$parameter[1],
nu2=x$parameter[2],
tail='lower', las=1,
shade.col=shade.col, cex=cex)
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
res<-list(statistic=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
plot.htest(x)
To<-function(base,alpha,M0){
Mmues<-c(unname(colMeans(base))) #varia segun la base sumistrada
n<- nrow(base) ##DEBE VARIAR SEGUN LA SELECCIÓN
S<-cov(base) # DEBE VARIAR SEGUN LA SELECCIÓN
Scom<-solve(S)
#obtencion del valor del EP-------
T0<-n*t(Mmues-M0)%*%Scom%*%(Mmues-M0)
p<-length(M0) # VARIA segÚn el tamaño de variables escogidas para el vector
a<-((n-1)*p/(n-p))
f<-(qf(alpha,p,n-p))*a
alternative =='less'
parameter<-c(p,n-p)
method<-c('F test to compare two variances')
res<-list(statistic=T0,p=p,n=n,Mmues=Mmues,S=S,
valor=f,
method=method,
alternative=alternative,
parameter=parameter)
class(res)<-"htest"
return(res)
}
x<-To(dt,0.05,c(4,50,10))
x
plot.htest(x)
shade.F(x)
clc
clear
clearPushBack()
